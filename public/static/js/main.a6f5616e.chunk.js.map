{"version":3,"sources":["favicon.png","redcoat-1-threshold.png","App.js","serviceWorker.js","index.js"],"names":["module","exports","dateFormat","require","clearWindowSelection","window","getSelection","empty","removeAllRanges","document","selection","Navbar","id","className","href","src","logo","this","props","pageTitle","Component","Category","item","index","children","childItems","open","map","key","openedItems","has","full_name","onClick","hotkeyMap","hotkeyChain","isTopLevelCategory","applyTag","hasHotkey","hasOwnProperty","hotkeyStr","join","content","data-hotkey-id","name","toString","draggableId","provided","snapshot","ref","innerRef","draggableProps","isDragging","colorId","dragHandleProps","CategoryHierarchy","state","itemOrder","orderedItems","Set","onDragEnd","bind","prevProps","prevState","t","Array","items","length","i","setupItemOrder","_","isEqual","setState","delete","add","result","destination","list","startIndex","endIndex","from","splice","removed","reorder","source","order","getOrderedItems","initHotkeyMap","droppableId","droppableProps","isDraggingOver","toggleCategory","placeholder","getColourIdx","entityClass","entityColourMap","split","slice","Label","colourIdx","e","deleteTag","Word","selected","hasLabel","annotation","tagClass","bioTag","isLastInSpan","labels","entityClasses","onMouseUp","updateSelections","onMouseDown","text","ConfidenceButton","docIdx","value","checked","updateConfidence","title","ConfidenceButtons","confidence","DocumentContainerHeader","DocumentContainer","displayIndex","words","annotations","selections","Sentence","wordIndex","action","node","$","domtoimage","toBlob","filter","classList","contains","bgcolor","then","blob","saveAs","isWordSelected","wordEndIndex","wordStartIndex","word","saveToPng","nextNode","hasChildNodes","firstChild","nextSibling","parentNode","HotkeyInfo","ec","undefined","chain","Annotation","token","tokenIndex","spanText","spanStartIdx","spanEndIdx","alreadyHasLabel","indexOf","push","otherAnnotation","console","log","WikipediaSummary","visible","querying","wikipediaSummary","wikipediaReadMoreUrl","tokens","next","snippet","wurl","wikipediaTitle","toLowerCase","ajax","url","data","srsearch","format","dataType","success","query","search","replace","err","getResult","queryWikipedia","summary","style","target","toggleVisibility","TaggingInterface","project_id","documentGroup","categoryHierarchy","pageNumber","annotatedDocGroups","documentGroupAnnotationId","confidences","getEmptySelectionsArray","currentSelection","getEmptyCurrentSelection","mostRecentSelectionText","reverseHotkeyMap","hotkeyBindingFn","hotkeyTimeoutFn","holdingCtrl","holdingShift","docGroupLastModified","totalPages","changesMade","recentlySaved","selectionChangeFn","windowMouseUpFn","loading","saving","firstLoad","showingProgressBar","taggingCompletePage","sel","rangeCount","r","range","startContainer","endNode","endContainer","rangeNodes","commonAncestorContainer","unshift","getRangeSelectedNodes","getRangeAt","removeClass","find","addClass","sentenceIndex","removeEventListener","selectionChange","windowMouseUp","addEventListener","preventDefault","moveSelectionHorizontally","moveSelectionVertically","hotkeyChainStr","clearTimeout","keyCode","prototype","concat","setTimeout","hotkeyTimeout","bindHotkeys","traverseChild","child","hotkeys","firstPass","Math","min","buildReverseHotkeyMap","setupHotkeyKeybinds","documents","automaticAnnotations","doc_idx","token_idx","parseInt","mention_idx","mention","start","end","label_idx","label","k","addLabel","ec_idx","each","ele","width","offsetWidth","newWidth","ceil","css","nextPageNumber","queryAPI","fetchConfig","method","headers","route","fetch","response","d","JSON","parse","alert","tagging_complete","projectName","initEntityColourMap","initConfidencesArray","initAnnotationsArray","lastModified","initKeybinds","initMouseEvents","clearWordJustification","justifyWords","selectFirstWord","scrollTo","annotationsJSON","docLabels","ann","csrfToken","cookieValue","cookie","cookies","trim","substring","decodeURIComponent","getCookie","annotationsToJSON","body","stringify","documentGroupId","newTotalPages","Date","now","pathname","location","direction","j","max","numDocs","clearSelections","s","sel_idx","annotationSpanStart","annotationSpanEnd","notAllEqual","removeAllLabels","x","setSpanEndIdx","setSpanStartIdx","changeBioTag","ann_idx","labelWasModified","captureEvent","spanStart","spanEnd","removeLabel","eventAction","event","docGroupsPerUser","totalPagesAvailable","submitAnnotations","loadPreviousPage","loadNextPage","doc","SaveButton","buttonClass","iconClass","ProgressBar","show","ControlBar","groupName","latestGroup","TaggingCompletePage","class","App","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a6f5616e.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/redcoat-1-threshold.78b878cf.png\";","import React from 'react';\nimport logo from './favicon.png'\nimport redcoatMan from './redcoat-1-threshold.png';\nimport './stylesheets/stylesheet.scss';\nimport {Component} from 'react';\nimport $ from 'jquery';\n//const ReactDragListView = require('react-drag-listview');\nimport { DragDropContext, Droppable, Draggable } from \"react-beautiful-dnd\";\nimport styled from 'styled-components';\nimport _ from 'underscore';\n\nimport html2canvas from 'html2canvas';\nimport { saveAs } from 'file-saver';\nimport domtoimage from 'dom-to-image';\nconst dateFormat = require('dateformat');\n\nconst BASE_URL = \"/\"\n\n\n\n// https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript\nfunction clearWindowSelection() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {  // Chrome\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {  // Firefox\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {  // IE?\n    document.selection.empty();\n  }\n}\n\n\n// Function for getting value from a cookie\nfunction getCookie(name) {\n    let cookieValue = null;\n    if (document.cookie && document.cookie !== '') {\n        const cookies = document.cookie.split(';');\n        for (let i = 0; i < cookies.length; i++) {\n            const cookie = cookies[i].trim();\n            // Does this cookie string begin with the name we want?\n            if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                break;\n            }\n        }\n    }\n    return cookieValue;\n}\n\n\n\n\n// The navbar, which appears at the top of the page.\nclass Navbar extends Component {\n  render() {\n    return (\n      <nav id=\"navbar\">\n        <div className=\"navbar-left\">\n          <div id=\"logo\">\n            <a href={BASE_URL}>\n              <span className=\"inner\">\n                <span className=\"img\">\n                  <img src={logo}/>\n                </span>\n                <span>Redcoat</span>\n              </span>\n            </a>\n          </div>\n        </div>\n        <div className=\"navbar-centre\">{this.props.pageTitle}</div>\n        <div className=\"navbar-right\">\n          <div className=\"dropdown-menu short\">\n            <a href=\"features\">v1.0</a>\n          </div>\n        </div>\n      </nav>\n    )\n  }\n}\n\n// A single category in the category hierarchy tree.\nclass Category extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    var item = this.props.item;\n    var index = this.props.index;\n    var children = this.props.item.children;\n\n    // If this component has any children, render each of them.\n    if(children) {\n      var childItems = (\n        <ul className={this.props.open ? \"\" : \"hidden\"}>\n          { children.map((item, index) => (\n            <Category key={index}\n                      item={item}\n                      open={this.props.openedItems.has(item.full_name)}\n                      openedItems={this.props.openedItems}\n                      onClick={this.props.onClick}\n                      hotkeyMap={this.props.hotkeyMap}\n                      hotkeyChain={this.props.hotkeyChain}\n                      isTopLevelCategory={false}\n                      applyTag={this.props.applyTag}\n            />)) }\n        </ul>\n      );\n    } else {\n      var childItems = '';\n    }\n\n    // Determine whether this category has a hotkey (by checking hotkeyMap).\n    // Also determine hotkeyStr (for example '12' for 'item/pump').\n    var hasHotkey = this.props.hotkeyMap.hasOwnProperty(this.props.item.full_name)\n    var hotkeyStr = hasHotkey ? this.props.hotkeyMap[this.props.item.full_name].join('') : '';\n\n    var content = (\n      <span className=\"inner-container\">\n        \n         {children && <span className=\"open-button\" onClick={() => this.props.onClick(item.full_name)}><i className={\"fa fa-chevron-\" + (this.props.open ? \"up\" : \"down\")}></i></span>}\n       \n        <span className={\"category-name\" + (hasHotkey ? \" has-hotkey\" :\"\") + (this.props.hotkeyChain === hotkeyStr ? \" hotkey-active\" : \"\")}\n              data-hotkey-id={hotkeyStr} onClick={() => this.props.applyTag(this.props.item.full_name)}>             \n\n          {item.name}\n        </span>\n      </span>      \n    )\n\n\n    // This component will render differently depending on whether it is a top-level category or not.\n    // Top level categories have the drag handle, which requires a different configuration on the wrapper and li.\n    if(this.props.isTopLevelCategory) {\n      return (\n        <Draggable key={item.id.toString()} draggableId={item.id.toString()} index={index}>\n          {(provided, snapshot) => (\n            <li ref={provided.innerRef} {...provided.draggableProps} className={\"draggable \" + (snapshot.isDragging ? \"dragging\": \"not-dragging\") + \" color-\" + (item.colorId + 1)}>\n              <div {...provided.dragHandleProps} className=\"drag-handle-container\"><span className=\"drag-handle\"></span></div>\n              \n              { content }\n              { childItems }\n              \n            </li>\n          )}\n        </Draggable>\n      )\n    } else {\n      return (\n        <li>\n          { content }\n          { childItems }\n        </li>\n      )\n    }\n  }\n}\n\n\n\n// https://codesandbox.io/s/k260nyxq9v?file=/index.js:154-2795\n// a little function to help us with reordering the result\nconst reorder = (list, startIndex, endIndex) => {\n  const result = Array.from(list);\n  const [removed] = result.splice(startIndex, 1);\n  result.splice(endIndex, 0, removed);\n\n  return result;\n};\n\n\n\n// Retrieve a list of ordered items based on an order array.\nfunction getOrderedItems(items, order) {\n  var orderedItems = new Array(items.length);\n  for(var i = 0; i < order.length; i++) {\n    orderedItems[i] = items[order[i]];\n  }\n  return orderedItems;\n}\n\n// The category hierarchy (on the left).\nclass CategoryHierarchy extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemOrder: [],      // An array that maintains the ordering of the top-level categories.\n                          // e.g. [0, 1, 3, 2]\n      orderedItems: [],\n      openedItems: new Set(),    // An set keep track of the items that have been open (indexed by name).\n    }\n    this.onDragEnd = this.onDragEnd.bind(this);\n  }\n\n  // When this component's items changes (should be when a new docGroup has been requested), setup a new itemOrder state.\n  // (which defaults to ascending order e.g. 0, 1, 2, 3, 4 ...)\n  componentDidUpdate(prevProps, prevState) {\n    var t = this;\n    function setupItemOrder() {\n      var itemOrder = new Array(t.props.items.length);\n      for(var i = 0; i < itemOrder.length; i++) {\n        itemOrder[i] = i;\n      }\n      return itemOrder;\n    }\n    \n    var itemOrder = setupItemOrder();\n    if(!_.isEqual(prevProps.items, this.props.items)) {\n      this.setState({\n        openedItems: new Set(),\n        orderedItems: this.props.items,\n        itemOrder: itemOrder,\n      });\n    }\n  }\n\n  // Open or close a category.\n  // It's pretty awkward that this function is necessary. It would be ideal to store 'open' as a state variable inside the Category and Subcategory\n  // components, but that results in the wrong categories being open when the top-level categories are moved around.\n  // Storing them in the openedItems array in this component's state allows for the opened categories to be maintained when the user\n  // drags a category from one place to another.\n  // full_name should be the full name of the category, e.g. item/pump/centrifugal_pump, which are unique.\n  toggleCategory(full_name) {\n    var openedItems = this.state.openedItems;    \n\n    if(openedItems.has(full_name)) {\n      openedItems.delete(full_name);\n    } else {\n      openedItems.add(full_name);\n    }\n\n    this.setState({\n      openedItems: openedItems\n    })\n  }\n\n  // When the user has finished dragging a category, determine the new item order and save this order to the state.\n  onDragEnd(result) {\n    // dropped outside the list\n    if (!result.destination) {\n      return;\n    }\n\n    const itemOrder = reorder(\n      this.state.itemOrder,\n      result.source.index,\n      result.destination.index\n    );\n\n    var orderedItems = getOrderedItems(this.props.items, itemOrder)\n\n    this.props.initHotkeyMap(orderedItems, () =>\n      this.setState({\n        itemOrder: itemOrder,\n        orderedItems: orderedItems,\n      })\n    );\n  }\n\n  \n  render() {\n\n    var items       = this.state.orderedItems;\n    var openedItems = this.state.openedItems;\n\n    return (\n      <div id=\"category-hierarchy-tree\">\n        <DragDropContext onDragEnd={this.onDragEnd}>\n          <Droppable droppableId=\"droppable\">\n            {(provided, snapshot) => (\n              <ul\n                {...provided.droppableProps}\n                className={\"draggable-list\" + (snapshot.isDraggingOver ? \" dragging\" : \"\")}\n                ref={provided.innerRef}\n\n              >\n                {items.map((item, index) => (\n                  <Category \n                            key={index}\n                            item={item}\n                            index={index}\n                            onClick={this.toggleCategory.bind(this)}\n                            open={openedItems.has(item.name)} \n                            openedItems={this.state.openedItems} \n                            hotkeyMap={this.props.hotkeyMap}\n                            hotkeyChain={this.props.hotkeyChain}\n                            isTopLevelCategory={true}\n                            applyTag={this.props.applyTag}\n                  />\n                ))}\n                {provided.placeholder}\n              </ul>\n            )}\n          </Droppable>\n        </DragDropContext>\n      </div>\n    );\n  }\n}\n\n\n// Returns the colour id of the given entityClass according to the entityColourMap, e.g.\n// 'item/pump': 1 (because \"item\" is the top level category)\nfunction getColourIdx(entityClass, entityColourMap) {\n  var baseClass = entityClass.split(\"/\").slice(0, 1)[0];\n  return entityColourMap[baseClass];\n}\n\n// A label, drawn underneath a word.\nclass Label extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <span className={\"label tag-\" + this.props.colourIdx} onClick={(e) => {this.props.deleteTag(this.props.entityClass);  }}><span className=\"label-name\">{this.props.entityClass}</span></span>\n    )\n  }\n}\n\n// A single word (or token) in the tagging interface.\nclass Word extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selected: false,\n    }\n  }\n\n  // Calls this.props.deleteTag with the index of this word as a parameter.\n  deleteTag(entityClass) {\n    this.props.deleteTag(this.props.index, entityClass);\n  }\n\n  render() {\n\n    var hasLabel = this.props.annotation.hasLabel();\n\n    var tagClass = hasLabel ? (\" tag \" + ((this.props.annotation.bioTag === \"B\") ? \"tag-begin\" : \"\") + (this.props.annotation.isLastInSpan() ? \" tag-end\" : \"\")) : \"\";\n\n    if(hasLabel) {\n      var labels = this.props.annotation.entityClasses.map((entityClass, i) => \n                  <Label deleteTag={this.deleteTag.bind(this)} key={i} bioTag={this.props.annotation.bioTag} entityClass={entityClass} colourIdx={getColourIdx(entityClass, this.props.entityColourMap)} />\n                  )\n      \n    } else {\n      var labels = '';\n    }\n\n    return (\n      <span className={\"word\" + (this.props.selected ? \" selected\" : \"\") + tagClass}\n        \n        >\n        <span className=\"word-inner\"\n              onMouseUp=  {() => this.props.updateSelections(this.props.index, 'up')}\n              onMouseDown={() => this.props.updateSelections(this.props.index, 'down')}>\n          {this.props.text}\n        </span>\n        { labels }\n      </span>\n    );\n  }\n}\n\n\n// A single confidence button, which may have the value 'low' 'medium' or 'high'.\nclass ConfidenceButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var docIdx = this.props.docIdx;\n    var value = this.props.value;\n    return (\n      <span className={\"confidence-button conf-\" + value + (this.props.checked ? \" checked\" : \"\")}\n            onClick={() => this.props.updateConfidence(docIdx, value)} title={\"Assign a \" + value + \" confidence to this document.\"} ></span>\n    )\n  }\n}\n\n\nclass ConfidenceButtons extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div className={\"confidence-buttons\"}>\n        <ConfidenceButton value=\"low\"    checked={this.props.confidence === \"low\"} { ...this.props }/>\n        <ConfidenceButton value=\"medium\" checked={this.props.confidence === \"medium\"} { ...this.props }/>\n        <ConfidenceButton value=\"high\"   checked={this.props.confidence === \"high\"} { ...this.props }/>        \n      </div>\n    )\n  }\n}\n\n\n// The document container header, which appears at the top of the sentence tagging page.\nclass DocumentContainerHeader extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div className=\"document-container header\">\n        <div className=\"document header\">\n          <div className=\"sentence-index\"></div>\n          <div className=\"sentence\">Document</div>\n          <div className=\"confidence-buttons\">Confidence</div>\n        </div>\n      </div>\n    )\n  }\n}\n\n// A document container, which contains the sentence index (on the left), the sentence, and the confidence buttons.\nclass DocumentContainer extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    return (\n      <div className={\"document-container\" + (this.props.confidence ? \" conf conf-\" + this.props.confidence : \"\")}>\n        <div className=\"document\">\n          <div className=\"sentence-index\"><span className=\"inner\">{this.props.displayIndex}</span></div>\n          <Sentence \n            index={this.props.index}\n            words={this.props.words}              \n            annotations={this.props.annotations}  \n            selections={this.props.selections}\n            updateSelections={this.props.updateSelections}\n            entityColourMap={this.props.entityColourMap}\n            deleteTag={this.props.deleteTag}\n          />\n          <ConfidenceButtons docIdx={this.props.index} confidence={this.props.confidence} updateConfidence={this.props.updateConfidence}/>\n        </div>\n      </div>\n    )\n  }\n\n}\n\n\n\n// A sentence in the tagging interface.\nclass Sentence extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  // Call the updateSelections function of the parent of this component (i.e. TaggingInterface), with this sentence's index included.\n  updateSelections(wordIndex, action) {\n    this.props.updateSelections(this.props.index, wordIndex, action)\n  }\n\n  deleteTag(wordIndex, entityClass) {\n    this.props.deleteTag(this.props.index, wordIndex, entityClass);\n  }\n\n  // Saves this sentence to a PNG file. wow!\n  saveToPng() {\n    var t = this;\n    var node = $(\"#sentence-tagging .sentence\")[this.props.index + 1];\n\n    function filter(node) {\n      if(node.classList) {\n        return !node.classList.contains('save-to-png');\n      }\n      return node;\n    }\n\n    domtoimage.toBlob(node, {filter: filter, bgcolor: '#fefefe'})\n    .then(function(blob) {\n      saveAs(blob, \"document-\" + t.props.index + \".png\"); \n    });\n\n  }\n\n  render() {\n\n    var selections = this.props.selections;\n\n    // Check props.selections to determine whether the word with a given index in this sentence is selected.\n    // This is passed to the word as a prop so that it can be highlighted accordingly.\n    function isWordSelected(wordIndex) {      \n      if(selections.length === 0) return false;     \n      for(var i = 0; i < selections.length; i++) {\n        var selection = selections[i];\n        if(selection.wordEndIndex < 0) continue;\n        if(selection.wordEndIndex >= wordIndex && wordIndex >= selection.wordStartIndex ) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return (\n      <div className=\"sentence\">\n        { this.props.words.map((word, i) => \n          <Word key={i}\n                index={i}\n                text={word}\n                selected={isWordSelected(i)}\n                annotation={this.props.annotations[i]}\n                updateSelections={this.updateSelections.bind(this)}\n                entityColourMap={this.props.entityColourMap}\n                deleteTag={this.deleteTag.bind(this)}\n          />)\n        }   \n        <div className=\"save-to-png\" onClick={this.saveToPng.bind(this)} title=\"Click to download a .png file of this document\"><i className=\"fa fa-download\"></i></div>     \n      </div>\n    );\n  }\n\n}\n\n\n// A simple function for traversing a list of nodes. Goes with the function below.\n// Both functions found on StackOverflow: https://stackoverflow.com/questions/7781963/js-get-array-of-all-selected-nodes-in-contenteditable-div\nfunction nextNode(node) {\n    if (node.hasChildNodes()) {\n        return node.firstChild;\n    } else {\n        while (node && !node.nextSibling) {\n            node = node.parentNode;\n        }\n        if (!node) {\n            return null;\n        }\n        return node.nextSibling;\n    }\n}\n\n// A function for traversing the nodes present in the range object, which allows us to determine all html nodes\n// corresponding to selected items (items in which part of them are highlighted).\n// Note that you can't see the highlighted text on the screen because it has been hidden by css.\nfunction getRangeSelectedNodes(range) {\n    var node = range.startContainer;\n    var endNode = range.endContainer;\n\n    // Special case for a range that is contained within a single node\n    if (node == endNode) {\n        return [node.parentNode];\n    }\n\n\n    // Iterate nodes until we hit the end container\n    var rangeNodes = [];\n    while (node && node != endNode) {\n        rangeNodes.push( node = nextNode(node) );\n    }\n\n    // Add partially selected nodes at the start of the range\n    node = range.startContainer;\n    while (node && node != range.commonAncestorContainer) {\n        rangeNodes.unshift(node);\n        node = node.parentNode;\n    }\n\n    return rangeNodes;\n}\n\n\n\n// A simple class for displaying information related to the hotkeys the user is currently pressing.\nclass HotkeyInfo extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var ec = this.props.entityClass;\n    if(ec === undefined) {\n      ec = '(not a valid class)';\n    }\n\n    return (\n      <div className={\"hotkey-info\" + (this.props.chain.length === 0 ? \" hidden\": \"\")}>\n        <span className=\"chain\">{this.props.chain}</span>: <span>{ec}</span>\n      </div>\n    )\n\n  }\n}\n\n\n// A class to store an annotation for a single token.\n// Seemed more logical to put all the annotation logic in one class rather than sticking it in the TaggingInterface component.\n// Each sentence will have one Annotation object per token.\n// Properties:\n/* \n   token: the token e.g. 'centrifugal'\n   tokenIndex: the index of the token in the sentence\n   bioTag: the BIO tag ('B', 'I' or 'O')\n   entityClasses: the array of entity classes AKA labels (e.g. ['Item', 'Item/Pump'])   \n   spanText: the text of the span that this annotation is within (e.g. 'centrifugal pump')\n   spanStartIdx: the start index of the span this annotation is in, e.g. 0 if it starts at the first word of the sentence\n   spanEndIdx: the end index as above, e.g. 1,\n*/\nclass Annotation {\n  constructor(token, tokenIndex) {\n    this.token = token;\n    this.tokenIndex = tokenIndex;\n    this.bioTag = \"O\";    \n  }\n\n  // Adds the specified entityClass to this annotation.\n  // bioTag: The bioTag, e.g. \"B\" or \"I\",\n  // entityClass: The entity class, e.g. \"Item/Pump\"\n  // text: The text of the span that this annotation is inside, e.g. \"centrifugal pump\".\n  // spanStartIdx, spanEndIdx: self explanatory (as above)\n  // nextAnnotation: The Annotation object for the next token in the sentence.\n  //                 When called during the dictionary annotation tagging, nextAnnotation is not necessary.\n  // Returns whether the label of this annotation was modified at all.\n  addLabel(bioTag, entityClass, spanText, spanStartIdx, spanEndIdx) {\n    \n    if(this.entityClasses === undefined) this.entityClasses = new Array();\n\n    var alreadyHasLabel = this.entityClasses.indexOf(entityClass) !== -1;\n    if(this.bioTag === bioTag && this.spanText === spanText && this.spanStartIdx === spanStartIdx && this.spanEndIdx === spanEndIdx && alreadyHasLabel) {\n      return false;\n    }\n\n    // Adjust the span.\n    this.bioTag = bioTag;\n    this.spanText = spanText;\n    this.spanStartIdx = spanStartIdx;\n    this.spanEndIdx = spanEndIdx;\n\n    // Add the entityClass to the entityClasses array for this Annotation.\n    // If it is already there, don't add it again.\n    if(!alreadyHasLabel) {\n      this.entityClasses.push(entityClass);\n    }\n    return true;\n  \n    // If the nextAnnotation is from the same mention (AKA span) as this one, and does not have exactly the same labels after\n    // the new class has been appended to this annotation's entityClasses, change its BIO tag to B.\n    // This is the part that ensures mentions are split up when the user changes the label of token(s) inside that mention.\n    // if(nextAnnotation) {\n    //   if(this.sameMention(nextAnnotation) && !this.sameEntityClasses(nextAnnotation) && nextAnnotation.hasLabel()) {\n    //     console.log(\"Changing bio tag to B\")\n    //     nextAnnotation.changeBioTag(\"B\");\n    //     nextAnnotation.setSpanStartIdx(spanEndIdx + 1)          \n    //   }\n    // }\n\n    // If the previous annotation is from the same mention as this one, and now no longer has the same labels,\n    // adjust the spanEndIdx to be the start of this new span -1.\n    // This ensures the tags are rendered correctly in the browser.\n    // Note that this seems to get called multiple times when applying tags because they are applied in reverse order,\n    // but the spanEndIdx will be set as below for the next annotation anyway so that shouldn't be an issue.\n    // if(prevAnnotation) {\n    //   if(this.sameMention(prevAnnotation) && !this.sameEntityClasses(prevAnnotation) && prevAnnotation.hasLabel()) {  \n    //     prevAnnotation.setSpanEndIdx(spanStartIdx - 1);\n    //   }\n    // }\n  }\n\n  removeAllLabels() {\n    delete this.entityClasses;\n    delete this.spanText;\n    delete this.spanStartIdx;\n    delete this.spanEndIdx;\n    this.bioTag = \"O\";\n  }\n\n  // Simple function to determine whether this annotation is in the same mention as another annotation.\n  sameMention(otherAnnotation) {\n    return otherAnnotation.spanStartIdx === this.spanStartIdx && otherAnnotation.spanEndIdx === this.spanEndIdx;\n  }\n\n  // Determine whether this annotation has the same labels as another annotation.\n  sameEntityClasses(otherAnnotation) {\n    return _.isEqual(this.entityClasses, otherAnnotation.entityClasses);\n  }\n\n  // Removes a label from this annotation.\n  // If it was the last label, reset this annotation's bioTag to \"O\" and delete the entityClasses and text properties.\n  removeLabel(entityClass) {\n    var index = this.entityClasses.indexOf(entityClass);\n    if(index === -1) {\n      console.log(\"Warning: tried to remove an entity class from an annotation that did not exist.\")\n      return;\n    }\n    this.entityClasses.splice(index, 1);\n    if(this.entityClasses.length === 0) {\n      this.bioTag = \"O\";\n      delete this.entityClasses;\n      delete this.spanText;\n      delete this.spanStartIdx;\n      delete this.spanEndIdx;\n    }\n  }\n\n  // Change the bio tag of this annotation to another bio tag.\n  changeBioTag(bioTag) {\n    this.bioTag = bioTag;\n  }\n\n  // Returns whether this annotations has a label.\n  hasLabel() {\n    return this.bioTag !== \"O\";\n  }\n\n  // Determines whether this annotation is the last of its type in the given span.\n  isLastInSpan() {\n    return this.spanEndIdx === this.tokenIndex;\n  }\n\n  setSpanStartIdx(spanStartIdx) {\n    this.spanStartIdx = spanStartIdx;\n  }\n\n  setSpanEndIdx(spanEndIdx) {\n    this.spanEndIdx = spanEndIdx;\n  }\n\n  // Prints this annotation nicely to the console (for debugging).\n  prettyPrint() {\n    console.log(\"Token:    \", this.token);\n    console.log(\"BIO Tag:  \", this.bioTag)\n    console.log(\"Span:     \", this.spanText)\n    console.log(\"StartIdx: \", this.spanStartIdx)\n    console.log(\"EndIdx: \", this.spanEndIdx)\n    console.log(\"Classes:  \\n\", this.entityClasses);\n    console.log('\\n');\n  }\n}\n\n// A debug printing function for printing out a list of annotations for a document.\nfunction prettyPrintAnnotations(documentAnnotations) {\n  console.log(\"Annotations:\\n\")\n  console.log(\"=====================\")  \n  for(var token_idx in documentAnnotations) {\n    documentAnnotations[token_idx].prettyPrint();\n  }\n}\n\nclass WikipediaSummary extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      visible: true,\n      querying: false, // Currently in the middle of a query\n      wikipediaSummary: null,\n      wikipediaReadMoreUrl: null,\n    }\n  }\n\n  queryWikipedia() {\n\n    var tokens = this.props.tokens;\n\n    // Query Wikipedia for the currently selected tokens.\n    function runQuery(next) {\n\n      // Processes the result of a Wikipedia query.\n      function getResult(data, next) {\n        function stripTags(str) {\n          return str.replace(/<\\/?[^>]+(>|$)/g, \"\");\n        }\n        try {\n          var title = data.query.search[0].title;\n          var snippet = stripTags(data.query.search[0].snippet);\n          var wurl = \"https://en.wikipedia.org/wiki/\" + data.query.search[0].title.replace(/ /g, '_');\n          return next(title, snippet, wurl);\n        } catch(err) {\n          next();\n        }\n      }\n      $.ajax({\n        url: 'https://en.wikipedia.org/w/api.php',\n        data: { action: 'query', list: 'search', srsearch: tokens, format: 'json' },\n        dataType: 'jsonp',\n        success: function(data) {\n          getResult(data, next);\n        }\n      });\n    } \n\n    this.setState({\n      querying: true\n    }, () => {\n      var wikipediaSummary, wikipediaReadMoreUrl;\n      var t = this;\n\n      runQuery(function(title, snippet, wurl) {\n        var wikipediaTitle = tokens;\n        if(snippet) {        \n          if(title.toLowerCase() !== tokens.toLowerCase()) {\n            wikipediaTitle = title;\n          }\n          wikipediaSummary = snippet + \"...\";\n          wikipediaReadMoreUrl = wurl;\n        } else {\n          wikipediaReadMoreUrl = null;\n          wikipediaSummary = null;  \n        }      \n\n        t.setState({\n          wikipediaTitle: wikipediaTitle,\n          wikipediaSummary: wikipediaSummary,\n          wikipediaReadMoreUrl: wikipediaReadMoreUrl,\n          querying: false,\n        })  \n      });\n\n    });\n  }\n\n  toggleVisibility() {\n    this.setState({\n      visible: !this.state.visible\n    })\n  }\n\n\n  componentDidUpdate(prevProps, prevState) {\n    if(prevProps.tokens !== this.props.tokens) {\n      this.queryWikipedia();\n    }\n  }\n\n  render() {    \n\n    if(!this.state.querying && this.state.wikipediaTitle && this.state.wikipediaTitle !== this.props.tokens) {\n      var title = <span className=\"different\">[{this.state.wikipediaTitle}] </span>\n    } else {\n      title = '';\n    }\n\n    var summary = this.state.wikipediaSummary ? this.state.wikipediaSummary : \"(no Wikipedia entry)\";\n    if(!this.props.tokens) {\n      summary = \"Select one or more words to automatically look them up on Wikipedia.\";\n    }\n    if(this.state.querying) {\n      summary = <span><i className=\"fa fa-spin fa-cog\"></i>&nbsp;&nbsp;Loading...</span>\n    }\n\n    // Rendering is a bit awkward, this could be tidied up\n    return (\n      <div className=\"tokens-info\">\n        <div id=\"wikipedia-summary-container\" className={this.state.visible ? \"show\" : \"hidden\"}>\n          <p className=\"tokens\">{this.props.tokens || 'Wikipedia lookup'}</p>\n          <p className=\"summary\">{ title }{ summary }</p>\n          <span className=\"more show\">\n            {(this.state.querying || !this.props.tokens) && <span className=\"left\" style={{\"color\": \"rgba(0, 0, 0, 0)\"}}>.</span>}\n            {!this.state.querying && this.props.tokens && <span className=\"left\">Results from Wikipedia</span>}\n            <span className=\"right\">\n              { !this.state.querying && this.props.tokens && <a id=\"ec-read-more\" href={this.state.wikipediaReadMoreUrl} target=\"_blank\">Read more <i className=\"fa fa-sm fa-external-link\"></i></a> } \n            </span>\n          </span>\n        </div>\n        <button id=\"wikipedia-hide-show\" className={this.state.visible ? \"up\" : \"down\"} onClick={this.toggleVisibility.bind(this)}>Show</button>\n      </div>\n    )\n  }\n}\n\n// The TaggingInterface class. Contains the vast majority of the logic for the interface.\nclass TaggingInterface extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project_id: 'RtJp98vxk', // debug\n\n      // Data (from the server)\n      // The data in this object is only changed by calling the queryAPI method.\n      data: {\n        documentGroup: [],\n        categoryHierarchy: {'children': []},\n        pageNumber: -1,\n        annotatedDocGroups: -1,\n      },\n\n      documentGroupAnnotationId: null, // The ID of the document group annotation object related to the document group the user is currently\n                                       // looking at. Will be null if the doc group has not been annotated by the user yet.\n                                       // Will be set when querying the API (for a previously annotated document group) or when\n                                       // submitting the annotations of a document group via submitAnnotations().\n\n      // Annotations array\n      annotations: [],  // Stores the user's annotations.\n      confidences: [],  // Stores the user's confidences.\n\n      // Selections\n      selections: this.getEmptySelectionsArray(10),       // The selections is an array containing a sub-array for each document,\n                                                          // which in turn hold all of the current selections made by the user for that\n                                                          // document.\n      currentSelection: this.getEmptyCurrentSelection(),  // The current selection is for when the user clicks a word and is in the process\n                                                          // of selecting an end word. \n      mostRecentSelectionText: null, // Keeps track of the tokens that the user most recently selected (for Wikipedia querying)\n      // Hotkeys\n      hotkeyMap: {},  // Stores a mapping of hotkey to number, e.g. 'item/pump': '11'.\n      reverseHotkeyMap: {}, // Stores the reverse of the above (number to hotkey), e.g. '11': 'item/pump'.\n      hotkeyChain: [], // Stores the current hotkey chain, e.g. [1, 2, 3] = the user has pressed 1, then 2, then 3 in quick succession\n      hotkeyBindingFn: null,  // Stores the function that gets called via an eventlistener when a hotkey is pressed. Must be stored as a state\n                              // variable so that it can be detached when the hotkeys change.\n      hotkeyTimeoutFn: null,   // Stores the current hotkey timeout function.\n\n      // Key events\n      holdingCtrl: false, // Whether the user is currently holding the ctrl key.\n      holdingShift: false, // Whether the user is currently holding the shift key.\n\n      entityColourMap: {}, // A mapping of the top-level entity classes to a colour\n\n      docGroupLastModified: null, // Stores when the current document group was last saved.\n\n      pageNumber: -1,\n      totalPages: -1,\n\n      changesMade: false, // Stores whether the user has made any changes to the current document group.\n      recentlySaved: false, // Whether the doc group has been recently saved\n\n      selectionChangeFn: null,\n      windowMouseUpFn: null,\n\n      loading: {  // Stores whether this interface is currently requesting a docgroup from the server, or saving one\n        querying: true,\n        saving: false,\n        firstLoad: true,\n      },\n      showingProgressBar: false, // Whether the progress bar is currently visible\n\n      taggingCompletePage: false, // Set to true when the user is on the 'tagging complete' page.\n\n    }    \n  }\n\n\n\n  // When the user highlights text anywhere on the page, this function captures the event.\n  // If the user never selected a word to begin with, nothing happens.\n  // All it does is apply the 'highlighted' class onto any words that were caught in the highlighting.\n  // This function is purely stylistic, i.e. it doesn't affect any other components etc.\n  selectionChange(e, words) {\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      return;\n    }\n    var sel = window.getSelection && window.getSelection();\n\n    if (sel && sel.rangeCount > 0) {\n      var r =  getRangeSelectedNodes(sel.getRangeAt(0));  \n      words.removeClass('highlighted');\n      $(r).find('.word-inner').addClass('highlighted');  \n    }\n  }\n\n  // When the user releases the mouse, remove all highlighting from words (i.e. the words in the selection).\n  // If the user never selected a word to begin with (i.e. wordStartIndex < 0), clear all selections.\n  windowMouseUp(e, words) {\n    words.removeClass('highlighted');\n    if(this.state.currentSelection.wordStartIndex < 0) {\n      clearWindowSelection();\n      return;\n    }\n    if(!e.target.classList.contains('word-inner')) { // Ensure that the user is not hovering over a word            \n      var sentenceIndex = this.state.currentSelection.sentenceIndex;\n      this.updateSelections(sentenceIndex, this.state.data.documentGroup[sentenceIndex].length - 1, 'up');\n    } \n  }\n\n  /* Mouse and keyboard events */\n\n  // Set up some mouse events - one for when text is selected (highlighted) in the browser.\n  // Note that in order to see the default browser highlighting the CSS file needs to be modified (it makes it invisible).\n  // Another for when the user releases the mouse anywhere on the page.\n  // Note that the majority of the mouse events are not in this function but are passed down to the Word elements via updateSelections.\n  // The event listeners need to be removed and reapplied to prevent duplication.\n  initMouseEvents() {\n\n    var words = $('.word-inner');\n\n    var selectionChangeFn = (e) => this.selectionChange(e, words);\n    var windowMouseUpFn = (e) => this.windowMouseUp(e, words);\n    \n    // Remove the old event listeners.\n    document.removeEventListener(\"selectionchange\", this.state.selectionChangeFn);   \n    window.removeEventListener('mouseup', this.state.windowMouseUpFn);\n\n    this.setState({\n      selectionChangeFn: selectionChangeFn,\n      windowMouseUpFn: windowMouseUpFn\n    }, () => {\n      // Add the new event listeners.\n      document.addEventListener(\"selectionchange\", this.state.selectionChangeFn);\n      window.addEventListener('mouseup', this.state.windowMouseUpFn);\n    });    \n  }\n\n  // Set up the key binds (ctrl, shift, left right up down etc).\n  // This function does not set up the hotkeys (that is done via setupHotkeyKeybinds)\n  initKeybinds() {\n\n    document.addEventListener('keydown', (e) => {\n      switch(e.key) {\n        case 'Shift':       if(!this.state.holdingShift) this.setState({ holdingShift: true }); break;\n        case 'Control':     if(!this.state.holdingCtrl) this.setState({ holdingCtrl: true }); break;\n\n        // For the arrows, call e.preventDefault() to prevent the window from scrolling\n        case 'ArrowLeft':   e.preventDefault(); this.moveSelectionHorizontally('left'); break; \n        case 'ArrowUp':     e.preventDefault(); this.moveSelectionVertically('up'); break;\n        case 'ArrowRight':  e.preventDefault(); this.moveSelectionHorizontally('right'); break;\n        case 'ArrowDown':   e.preventDefault(); this.moveSelectionVertically('down'); break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      switch(e.key) {\n        case 'Shift':   if(this.state.holdingShift) this.setState({ holdingShift: false }); break;\n        case 'Control': if(this.state.holdingCtrl) this.setState({ holdingCtrl: false }); break;\n      }      \n    });\n  }\n\n\n\n  /* Hotkey functions */\n\n  // When the user has pressed a hotkey that is not quickly followed up with another hotkey, this function is called.\n  // Apply the corresponding entity class and reset the hotkey chain.\n  hotkeyTimeout() {\n    var hotkeyChainStr = this.state.hotkeyChain.join('');\n    var entityClass = this.state.reverseHotkeyMap[hotkeyChainStr];\n    if(entityClass !== undefined) this.applyTag(entityClass);\n\n    // Clear the existing hotkey timeout fn.\n    window.clearTimeout(this.state.hotkeyTimeoutFn);\n    this.setState({\n      hotkeyTimeoutFn: null,      \n      hotkeyChain: [],\n    })\n  }\n\n  // This function is called when a hotkey is pressed.\n  // If a hotkey was pressed previously within 333ms, the chain will grow until the point the user no longer presses a hotkey\n  // for 333ms.\n  bindHotkeys(e, hotkeyMap) {\n    if(e.keyCode < 49 || e.keyCode > 57) return; // Hotkeys are in the range 1-9, which are keyCode 49-57.\n    var key = e.keyCode - 48;\n\n    // Update the hotkey chain to include the key that was pressed\n    var hotkeyChain = Array.prototype.concat(this.state.hotkeyChain, key);\n    this.setState({\n      hotkeyChain: hotkeyChain\n    }, () => {\n      // Remove the previous timeout and set up a new one\n      window.clearTimeout(this.state.hotkeyTimeoutFn);      \n      var hotkeyTimeoutFn = window.setTimeout(() => this.hotkeyTimeout(), 333);\n\n      this.setState({\n        hotkeyTimeoutFn: hotkeyTimeoutFn\n      });\n    });\n  }\n\n  // Assign keybinds to each of the hotkeys in the hotkey map.\n  setupHotkeyKeybinds() {\n    \n    console.log(\"Setting up hotkey keybinds...\")\n\n    // Clear the current hotkey binding function and set up a new one.\n    document.removeEventListener('keydown', this.state.hotkeyBindingFn);\n    var hotkeyBindingFn = (e) => this.bindHotkeys(e, this.state.hotkeyMap);\n\n    document.addEventListener('keydown', hotkeyBindingFn);\n\n    // Store the binding function in this.state so that it can be removed in subsequent calls of this function.\n    this.setState({\n      hotkeyBindingFn: hotkeyBindingFn,\n    });\n  }\n\n  // Builds the hotkey map according to the ordered category hierarchy, and saves it to this component's state.\n  // The hotkey map will change whenever the user changes the order of them items via drag and drop.\n  initHotkeyMap(orderedItems, next) {\n\n    console.log(\"Setting up hotkey map...\")\n    // Annoying that the following is a recursive function but I think it's the only way to do it.\n    // The result is a hotkeyMap as follows:\n    /*  {\n          'item': [1],\n          'item/pump': [1, 1],\n          'item/pump/centrifugal_pump': [1, 1, 1],\n          'item/pump/big_pump': [1, 1, 2],\n          'item/compressor': [1, 2],\n          'activity': [2]\n        }\n    */\n    function traverseChild(child, index, hotkeyMap, hotkeys, firstPass) {\n      if(!firstPass) {\n        hotkeyMap[child.full_name] = hotkeys;\n      }\n      if(child.children) {\n        for(var i = 0; i < Math.min(9, child.children.length); i++) { // Don't go past index 9 so that the hotkeys make sense\n          traverseChild(child.children[i], i + 1, hotkeyMap, Array.prototype.concat(hotkeys, i + 1));\n        }\n      }\n      return hotkeyMap;          \n    }    \n\n    // Build the reverse of the hotkeyMap, i.e. swap the keys with the values.\n    // This assists with the hotkey bindings function.\n    function buildReverseHotkeyMap(hotkeyMap) {\n      var reverseHotkeyMap = {};\n      for(var key in hotkeyMap){\n        var val = hotkeyMap[key].join('');\n        reverseHotkeyMap[val] = key;\n      }\n      return reverseHotkeyMap;    \n    }\n\n\n    var hotkeyMap = traverseChild({children: orderedItems}, 1, [], [], true);\n    var reverseHotkeyMap = buildReverseHotkeyMap(hotkeyMap);\n\n    // Once the hotkeyMap (and reverseHotkeyMap) has been created, set up the hotkey keybinds and call the callback fn.\n    this.setState({\n      hotkeyMap: hotkeyMap,\n      reverseHotkeyMap: reverseHotkeyMap\n    }, () => { this.setupHotkeyKeybinds(); if(next) next(); });\n  }\n\n\n  // Sets up an array to store the annotations with the same length as docGroup.\n  // Prepopulate the annotations array with the automaticAnnotations if available (after converting them to BIO).\n  // This could be either the dictionary-based annotations or the annotations that the user has previously entered.\n  initAnnotationsArray(documents, automaticAnnotations) {\n\n    var annotations = new Array(documents.length);\n    for(var doc_idx in documents) {\n      annotations[doc_idx] = new Array(documents[doc_idx].length);\n      for(var token_idx in documents[doc_idx]) {\n        annotations[doc_idx][token_idx] = new Annotation(documents[doc_idx][token_idx], parseInt(token_idx));\n      }\n    }\n\n    if(!automaticAnnotations) return annotations;\n\n    // Load annotations from the automaticAnnotations array if present.\n    for(var doc_idx in automaticAnnotations) {\n      for(var mention_idx in automaticAnnotations[doc_idx]['mentions']) {\n\n        var mention = automaticAnnotations[doc_idx]['mentions'][mention_idx];\n        var start = mention['start'];\n        var end = mention['end'];\n\n        for(var label_idx in mention['labels']) {\n          var label = mention['labels'][label_idx];\n\n          for(var k = start; k < end; k++) {\n            var bioTag = k === start ? 'B' : \"I\";\n            annotations[doc_idx][k].addLabel(bioTag, label, documents[doc_idx].slice(start, end).join(' '), start, end - 1)\n          }\n        }\n      }        \n    }\n    return annotations;\n  }\n\n  // Initialise the confidences array.\n  initConfidencesArray(documents) {\n    var confidences = new Array(documents.length);\n    return confidences;\n  }\n\n  // Initialise the entity colour map, which maps entity_class: colour_index, e.g. \"Item\": 1. Passed to the Word components to colour\n  // their labels accordingly.\n  initEntityColourMap(categoryHierarchy) {\n    var entityColourMap = {}\n    for(var ec_idx in categoryHierarchy) {\n      var entityClass = categoryHierarchy[ec_idx];\n      entityColourMap[entityClass.name] = entityClass.colorId + 1;\n    }\n    return entityColourMap;\n  }\n\n\n  /* Miscellaneous */\n\n  // Justify the words to the nearest 25px (i.e. round their width up to the nearest 25px).\n  // Not really necessary but makes the diagonal stripey lines line up properly when multiple tokens are selected.\n  // I spent about 2 hours trying to figure out how to get the stripey lines to line up properly, this is the result :D\n  justifyWords() {\n    $('.word-inner').each((i, ele) => {\n      var width = ele.offsetWidth;\n      var newWidth = Math.ceil(width / 25) * 25;\n      $(ele).css('min-width', newWidth + 'px');\n    });\n  }\n\n  // Remove min-width from words that do not have a tag\n  // (necessary to call between pages)\n  clearWordJustification() {\n    $('.word:not(.tag) .word-inner').each((i, ele) => {\n       $(ele).css('min-width', 'auto');\n    })\n  }\n\n  // Load the next page by calling the API.\n  // Query without a page number (i.e. request the latest group)\n  // if the user is looking at the group before the latest group.\n  //\n  // TODO: Make it so that when the user has made a change to the group they're looking at,\n  // pop up a confirmation window to confirm their changes before loading the next page?\n  loadNextPage() {\n    var nextPageNumber = this.state.pageNumber + 1;\n    if(nextPageNumber === (this.state.totalPages)) {\n      this.queryAPI(false);\n    } else {\n      this.queryAPI(false, nextPageNumber);\n    }\n  }\n\n  // Load the previous page by calling the API.\n  loadPreviousPage() {\n    this.queryAPI(false, this.state.pageNumber - 1);\n  }\n\n  /* API calls */\n\n  queryAPI(firstLoad, pageNumber) {\n    const fetchConfig = {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      }\n    };\n    var route = 'getDocumentGroup';\n\n    // If this function was called with a pageNumber, load a specific documentGroupAnnotation.\n    if(pageNumber) {\n      route = 'getPreviouslyAnnotatedDocumentGroup?pageNumber=' + pageNumber;\n    }\n\n    this.setState({\n      loading: {\n        querying: true,\n        saving: false,\n        firstLoad: firstLoad,\n      }\n    }, function() {\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/' + route, fetchConfig) // TODO: move localhost out\n        .then(response => response.text())\n        .then((data) => {\n          try { \n            var d = JSON.parse(data);\n          } catch(err) {\n            alert(err);\n            return;\n          }\n\n\n          if(d.tagging_complete) {\n            console.log(d);\n            this.setState({\n              taggingCompletePage: true,\n              totalPages: d.annotatedDocGroups + 1,\n              pageNumber: d.annotatedDocGroups + 1,\n              changesMade: false,\n              recentlySaved: false,\n\n              loading: {\n                querying: false,\n                saving: false,\n              },\n              data: {\n                projectName: d.projectName,\n                documentGroup: [],\n                categoryHierarchy: {'children': []},\n                pageNumber: -1,\n                annotatedDocGroups: -1,\n              },\n            })\n            return;\n          } \n\n          \n          this.setState(\n            {\n              data: d,\n              entityColourMap: this.initEntityColourMap(d.categoryHierarchy.children),\n              confidences: this.initConfidencesArray(d.documentGroup),\n              annotations: this.initAnnotationsArray(d.documentGroup, d.automaticAnnotations),\n              selections: this.getEmptySelectionsArray(d.documentGroup.length),\n              mostRecentSelectionText: null,\n              pageNumber: d.pageNumber,\n              totalPages: d.annotatedDocGroups + 1,\n              docGroupLastModified: d.lastModified,\n              documentGroupAnnotationId: d.documentGroupAnnotationId, // Will be null if this doc group has not yet been annotated\n              changesMade: false,\n              recentlySaved: false,\n              loading: {\n                querying: false,\n                saving: false\n              },     \n              taggingCompletePage: false,         \n            }, () => { \n              console.log(\"Data:\", this.state.data);\n\n              // Initialise keybinds and mouse events only on the first API call.\n              if(firstLoad) {\n                this.initKeybinds();              \n                this.initHotkeyMap(this.state.data.categoryHierarchy.children);   \n              }\n\n              this.initMouseEvents();\n              this.clearWordJustification();    \n              this.justifyWords();    \n              this.selectFirstWord();\n\n              window.scrollTo(0, 0);\n            })\n        });\n        \n\n    }.bind(this));\n  }\n\n  // Convert the annotations array into JSON.\n  annotationsToJSON() {\n    var annotations = this.state.annotations;\n    var annotationsJSON = [];\n    for(var doc_idx in annotations) {\n        \n      var docLabels = [];\n      for(var token_idx in annotations[doc_idx]) {\n        var ann = annotations[doc_idx][token_idx];\n        if(ann.entityClasses) {\n          docLabels.push([ann.bioTag + \"-\", ann.entityClasses]);\n        } else {\n          docLabels.push([\"\"])\n        }\n      }\n      annotationsJSON.push(docLabels);\n    }\n    return annotationsJSON;\n  }\n\n\n  // Submit the annotations of the document group that the user is currently looking at.\n  // TODO: Maybe make it so that you can't save the annoations until the user has put all their confidences in?\n  // Or perhaps do a check and pop a confirmation window up if they click save without doing anything to >= 1 document\n  submitAnnotations() {\n    if(this.state.recentlySaved) { return; } // If the user clicks on the green save button, provide them with the illusion that it is doing\n                                             // something when in fact nothing actually happens. Prevents people from spam clicking the save and\n                                             // calling the API 5000 times...\n                                             // It's kind of like how google sheets allows you to press Ctrl + S despite it saving every action\n                                             // automatically.\n\n    const csrfToken = getCookie('csrf-token');\n\n    var annotationsJSON = this.annotationsToJSON();\n\n    const fetchConfig = {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'csrf-token': csrfToken,\n      },\n      dataType: \"json\",\n      body: JSON.stringify({\n        documentGroupId: this.state.data.documentGroupId,\n        documentGroupAnnotationId: this.state.documentGroupAnnotationId,\n        labels: annotationsJSON\n      }),  \n    };\n\n    this.setState({\n      loading: {\n        querying: false,\n        saving: true,\n      }\n    }, () => {\n\n      fetch('http://localhost:3000/projects/' + this.state.project_id + '/tagging/submitAnnotations', fetchConfig) // TODO: move localhost out\n      .then(response => response.text())\n      .then((data) => {\n        try { \n          var d = JSON.parse(data);\n\n          console.log(d);\n\n          var documentGroupAnnotationId = d.documentGroupAnnotationId;\n          console.log(\"Submitted annotations OK\");\n\n          // If the user is on the last page (i.e. the 'current group'), add one to the totalPages array so that the user can\n          // click 'Next' to go to the latest doc group.\n          if(this.state.pageNumber === this.state.totalPages) {\n            var newTotalPages = this.state.totalPages + 1;\n            this.setState({\n              showingProgressBar: true,\n            }, () => {\n              window.setTimeout(() => this.setState({\n                showingProgressBar: false,\n              }), 3000);\n            })\n\n          } else {\n            var newTotalPages = this.state.totalPages;\n          }\n\n          this.setState({\n             docGroupLastModified: Date.now(),\n             totalPages: newTotalPages,\n             changesMade: false,\n             recentlySaved: true,\n             documentGroupAnnotationId: documentGroupAnnotationId,\n             loading: {\n              querying: false,\n              saving: false\n             }\n          });\n        } catch(err) {\n          console.log(\"ERROR:\", err);\n          alert(data);\n        }\n        \n        //this.queryAPI(this.state.data.pageNumber + 1);\n      });\n    });\n  }\n\n  /* Mounting function */\n\n  // When this component is mounted, call the API.\n  // Set up the keybinds and mouseup event when done.\n  componentWillMount() {\n\n    var pathname = window.location.pathname;\n    var project_id = pathname.split('/')[2];\n    if(pathname === \"/\") {\n      //var project_id = 'RtJp98vxk'; // React development (completed project)\n      var project_id = '-krXeW3R2'; // React development (big one)\n    }\n    if(!project_id || project_id.length < 8) {\n      alert(\"invalid project\");\n      return;\n    }\n\n\n\n    this.setState({\n      project_id: project_id\n    }, () => { this.queryAPI(true) });\n  }  \n\n  /* Selection functions */\n\n  // Get an empty current selection.\n  // Called when we need to clear the current selection.\n  getEmptyCurrentSelection() {\n    return {\n      wordStartIndex: -1,\n      wordEndIndex: -1,\n      sentenceIndex: -1\n    }\n  }\n\n  // Move the selection up or down.\n  // This function should be called when one of those keys is pressed.\n  moveSelectionVertically(direction) {\n    console.log(\"Moving\", direction) // TODO: Make this move up and down\n  }\n\n  // Move the selection in the specified direction ('left', 'right').\n  // This function should be called when one of those keys is pressed.\n  moveSelectionHorizontally(direction) {\n    console.log(\"Moving\", direction)\n\n    var selections = this.state.selections;\n    var mostRecentSelectionText;\n\n    // Move all selections left or right\n    for(var i = 0; i < selections.length; i++) {\n      for(var j = 0; j < selections[i].length; j++) {\n        var selection = selections[i][j];\n\n        // Behaviour depends on whether shift is currently being held down.\n        if(direction === \"left\") {\n          if(!this.state.holdingShift) {\n            selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            selection.wordEndIndex = selection.wordStartIndex;\n          } else { // If shift is being held down, move the wordEndIndex backwards or move the wordStartIndex backwards depending on the current selection.\n            if(selection.wordEndIndex > selection.wordStartIndex) {\n              selection.wordEndIndex--;\n            } else {\n              selection.wordStartIndex = Math.max(selection.wordStartIndex - 1, 0);\n            }\n          }\n        } else if (direction === \"right\") {\n          if(!this.state.holdingShift) { // If shift *is* being held down, this won't happen (the wordStartIndex won't change).\n            selection.wordStartIndex = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n          }\n          selection.wordEndIndex   = Math.min(this.state.data.documentGroup[i].length - 1, selection.wordEndIndex + 1);\n        }\n\n        mostRecentSelectionText = this.state.data.documentGroup[i].slice(selection.wordStartIndex, selection.wordEndIndex + 1).join(' ');\n      }\n    }\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText\n    });\n  }\n\n  // Get an empty selections array whose length is the number of docs in the current documentGroup.\n  getEmptySelectionsArray(numDocs) {\n    if(!numDocs) {\n      var numDocs = this.state.data.documentGroup.length;\n    }\n    var selections = new Array(numDocs);\n    for(var i = 0; i < selections.length; i++) {\n      selections[i] = new Array();\n    }    \n    return selections;\n  }  \n\n  // Select the first word in the first sentence.\n  // (called when a new group is loaded).\n  selectFirstWord() {\n    var selections = this.state.selections;\n    selections[0].push({\n      wordStartIndex: 0,\n      wordEndIndex: 0\n    });\n    this.setState({\n      selections: selections,\n      mostRecentSelectionText: this.state.data.documentGroup[0][0],\n    });\n  }\n\n  // Clear all active selections by resetting the selections array.\n  clearSelections() {\n    this.setState( {\n      currentSelection: this.getEmptyCurrentSelection(),\n      selections: this.getEmptySelectionsArray()\n    });\n  }\n\n  // Update this component's selections state.\n  // This function is called via the mouse, and has no relation to the keyboard (keyboard selections are handled above).\n  // sentenceIndex: The index of the sentence in which the selection was made.\n  // wordIndex: the index of the word that was clicked on, or hovered over and the mouse released.\n  // action: Whether the mouse was pressed down ('down') or released ('up').\n  updateSelections(sentenceIndex, wordIndex, action) {\n    var wordStartIndex, wordEndIndex;\n\n    var selections = this.state.selections;\n    var currentSelection = this.state.currentSelection;\n\n    if (action === \"down\") { // Mouse down, i.e. a word was clicked.\n\n      if(!this.state.holdingCtrl) {\n        selections = this.getEmptySelectionsArray(); // Reset all selections upon clicking a word, unless Ctrl is being held.\n      }\n      wordStartIndex = wordIndex;\n      wordEndIndex = -1;\n\n      // A new selection is made, capturing the index of the sentence that the user clicked on and the index of the word that they clicked.\n      currentSelection = {\n        sentenceIndex: sentenceIndex,\n        wordStartIndex: wordStartIndex\n      }      \n\n    } else if(action === \"up\") { // Mouse up, i.e. mouse was released when hovering over a word.\n\n      // Only allow selections where the user has clicked on a starting word.\n      if(currentSelection.wordStartIndex === -1) {\n        this.clearSelections();\n        return;\n      }\n\n      wordStartIndex = currentSelection.wordStartIndex;\n\n      // If the first word selected was in a different sentence, the wordStartIndex becomes the start of the sentence where the mouse was released.\n      if(currentSelection.sentenceIndex !== sentenceIndex) {  // TODO: Make this consider mouseX relative to the X of the initial token?\n        wordStartIndex = 0;\n      };\n\n      wordEndIndex = wordIndex;\n\n      // If the second word selected was before the first, swapperino them around (so that backwards selections work as expected).\n      if(wordIndex < wordStartIndex) {\n        var s = wordStartIndex;\n        wordStartIndex = wordIndex;\n        wordEndIndex = s;\n      }     \n\n      // Create a new selections json object and push it to the selections array for this sentence.\n      currentSelection = this.getEmptyCurrentSelection();\n      selections[sentenceIndex].push({\n        wordStartIndex: wordStartIndex,\n        wordEndIndex: wordEndIndex\n      });\n      var mostRecentSelectionText = this.state.data.documentGroup[sentenceIndex].slice(wordStartIndex, wordEndIndex + 1).join(' ');\n\n      clearWindowSelection(); // Remove the default browser selection highlighty thing.\n    }    \n\n    this.setState({\n      currentSelection: currentSelection,\n      selections: selections,\n      mostRecentSelectionText: mostRecentSelectionText ? mostRecentSelectionText : this.state.mostRecentSelectionText,\n    });\n  }\n\n\n\n\n  /* Tag application function */\n\n  // Apply a specific tag to all current selections.\n  // entityClass: The full name of the entity class, e.g. 'item/pump/centrifugal_pump'.\n  // This function will either be called via clicking on an entity class in the tree, or by using hotkeys.\n  applyTag(entityClass) {    \n    //console.log(\"Applying tag:\", entityClass);\n    var selections = this.state.selections;\n    var documents = this.state.data.documentGroup;\n    var annotations = this.state.annotations;\n\n    for(var doc_idx in selections) {\n      for(var sel_idx in selections[doc_idx]) {\n        var sel = selections[doc_idx][sel_idx];\n        var start = sel.wordStartIndex;\n        var end = sel.wordEndIndex;\n\n\n        /* 1. Disjoint spans */\n        // Check all labels across this selected span of tokens are the same before proceeding.\n        // If they are not, they must be cleared before adding a label.\n        var annotationSpanStart = annotations[doc_idx][start].spanStartIdx;\n        var annotationSpanEnd   = annotations[doc_idx][start].spanEndIdx;\n        var notAllEqual = false;          \n        for(var k = start + 1; k <= end; k++) {\n          var otherAnnotation = annotations[doc_idx][k]; \n          if(annotationSpanStart !== otherAnnotation.spanStartIdx || annotationSpanEnd !== otherAnnotation.spanEndIdx) {\n            notAllEqual = true;\n            break;\n          }          \n        }        \n\n        // If the labels across all tokens in the selected span are not the same, remove all labels for the entire span.\n        // Then modify the spanEndIdx of any annotations in this document whose spanEndIdx was overlapping the\n        // span that the user selected, setting them to be start index - 1 (before the span).\n        // This ensures the ends of the spans are drawn properly.\n        if(notAllEqual) {\n          for(var k = start; k <= end; k++) {\n            var annotation = annotations[doc_idx][k];\n            annotation.removeAllLabels();\n          }          \n          // Adjust the span end index of all prev labels to be start index - 1\n          // A shame that we have to iterate across all annotations in this document - this could probably be optimised\n          // but it probably barely impacts performance even on large docs (I think)\n          for(var x in annotations[doc_idx]) {\n            var annotation = annotations[doc_idx][x];\n\n\n            // If this new span overlaps the *end* of an existing span, change that span's end index to the start of this new\n            // span, -1\n\n            if(annotation.spanEndIdx >= start && annotation.spanStartIdx <= start) {              \n              annotation.setSpanEndIdx(start - 1);\n\n            }\n\n            // If this new span overlaps the *start* of an existing span, change that span's start index to be the end of this new span -1\n            // and change the BIO tag to \"B\".\n            if(annotation.spanStartIdx <= end) {\n              annotation.setSpanStartIdx(end + 1);              \n              if(annotation.tokenIndex === (end + 1)) {\n                annotation.changeBioTag(\"B\") // I am realising now that this BIO tag is unnecessary - it could be inferred\n              }\n            }\n          }\n        }\n\n        /* 2. Overlapping spans */\n        // Check for any spans that this new span will cut into.\n        // First, check to the left and adjust the spanEndIdx of all Annotation objects\n        // to the left of this span if they overlap.\n        for(var ann_idx in annotations[doc_idx].slice(0, start)) {\n          var annotation = annotations[doc_idx][ann_idx];          \n          if(annotation.spanStartIdx < start && annotation.spanEndIdx >= end) {            \n            annotation.setSpanEndIdx(start - 1);\n          }\n        }\n\n        // Do the same for any Annotation objects on the right hand side of this span, which are part of the same\n        // mention.\n        for(var ann_idx in annotations[doc_idx].slice(end + 1, annotations[doc_idx].length)) {\n          var annotation = annotations[doc_idx][parseInt(ann_idx) + end + 1];\n          if(annotation.spanStartIdx <= start && annotation.spanEndIdx >= end) {\n            annotation.setSpanStartIdx(end + 1);\n            if(ann_idx === '0') {\n              annotation.changeBioTag(\"B\");\n            }\n          }\n        }\n\n        /* 3. Applying the labels */\n        // Now, apply the tags to every token in the selected span.\n        var labelWasModified = false;\n        for(var k = start; k <= end; k++) {\n          var bioTag = k === start ? \"B\" : \"I\";\n          var spanText = documents[doc_idx].slice(start, end + 1).join(' ');\n\n          //var prevAnnotation = k > 0 ? annotations[doc_idx][k - 1] : null;\n          //var nextAnnotation = k < (documents[doc_idx].length - 1) ? annotations[doc_idx][k + 1] : null;          \n\n          labelWasModified = annotations[doc_idx][k].addLabel(bioTag, entityClass, spanText, start, end);\n\n        }\n\n        if(labelWasModified) this.captureEvent('Applied label', parseInt(doc_idx), start, end, entityClass);\n      }\n    }\n    this.setState({\n      annotations: annotations,\n    }, () => {\n      this.justifyWords(); // Justify the words again to ensure the stripey lines line up correctly\n\n      // Debug:\n      //prettyPrintAnnotations(this.state.annotations[0]);\n      //console.log(\"Updated annotations[0]:\", this.state.annotations[0]);\n    })\n\n  }\n\n  // Deletes the specified tag.\n  deleteTag(sentenceIndex, wordIndex, entityClass) {\n    \n    var annotations = this.state.annotations;\n    var annotation = annotations[sentenceIndex][wordIndex];\n\n    // Retrieve the span start idx and span end idx of the annotation corresponding to (sentence_index, word_index)\n    var spanStart = annotation.spanStartIdx;\n    var spanEnd = annotation.spanEndIdx;\n\n    this.captureEvent('Deleted label', sentenceIndex, spanStart, spanEnd, entityClass);\n\n    // Find all annotations in this document in the same mention span and remove the label from all of them.\n    // (this will also remove the label from the annotation object at (sentence_index, word_index)).\n    for(var ann_idx in annotations[sentenceIndex]) {\n      var otherAnnotation = annotations[sentenceIndex][ann_idx];       \n      if(otherAnnotation.spanStartIdx === spanStart && otherAnnotation.spanEndIdx === spanEnd) {\n        otherAnnotation.removeLabel(entityClass);\n      }\n    }\n\n    this.setState({\n      annotations: annotations\n    })\n\n  }\n\n  /* Confidence */\n\n  // Updates the confidences array for the given doc.\n  // If the user clicks on the button they already clicked, then the confidence is reset to undefined.\n  updateConfidence(sentenceIndex, confidence) {\n    var confidences = this.state.confidences;\n    if(confidences[sentenceIndex] === confidence) {\n      confidences[sentenceIndex] = undefined;\n    } else {\n      confidences[sentenceIndex] = confidence;\n    }\n    this.setState({\n      confidences: confidences\n    });\n  }\n\n  /* Events */\n\n  // Capture an event\n  // TODO: Make it do something\n  captureEvent(eventAction, sentenceIndex, spanStart, spanEnd, entityClass) {\n\n    var tokenString = this.state.data.documentGroup[sentenceIndex].slice(spanStart, spanEnd + 1).join(' ')\n\n    var event = {\n      \"action\": eventAction,\n      \"sentenceIndex\": sentenceIndex,\n      \"wordIndex\": {\n        \"start\": spanStart,\n        \"end\": spanEnd,\n      },\n      \"entityClass\": entityClass,\n      \"tokenString\": tokenString\n    }\n\n    console.log(event);\n    if(eventAction === \"Applied label\" || eventAction === \"Deleted label\") {\n      this.setState({\n        changesMade: true,\n        recentlySaved: false,\n      })\n    }\n\n  }\n\n  /* Rendering function */\n\n\n  render() {\n\n\n    var taggingCompletePage = this.state.taggingCompletePage;\n\n    return (\n      <div id=\"app\">      \n        <Navbar pageTitle={\"Annotating project: \" + this.state.data.projectName}/>  \n        <div id=\"tagging-interface\" className={(this.state.loading.querying ? \"loading\" : \"\") + (taggingCompletePage ? \" tagging-complete-page\" : \"\")}>\n\n          <div id=\"tagging-container\">\n            { taggingCompletePage && <TaggingCompletePage/>}\n            <div id=\"sentence-tagging\">\n\n              { this.state.loading.firstLoad && \n                <div className=\"loading-message\">\n                  <i className=\"fa fa-cog fa-spin\"></i>Loading...\n                </div>\n              }\n\n              <ControlBar\n                showingProgressBar = {this.state.showingProgressBar}\n                pageNumber = {this.state.pageNumber}\n                totalPages = {this.state.data.docGroupsPerUser}\n                totalPagesAvailable = {this.state.totalPages}\n                lastModified={this.state.docGroupLastModified}\n                recentlySaved={this.state.recentlySaved}\n                changesMade={this.state.changesMade}\n                querying={this.state.loading.querying}\n                saving={this.state.loading.saving}\n\n                submitAnnotations={this.submitAnnotations.bind(this)}\n                loadPreviousPage={this.loadPreviousPage.bind(this)}\n                loadNextPage={this.loadNextPage.bind(this)}\n              />\n\n              <DocumentContainerHeader/>\n                  \n              { this.state.data.documentGroup.map((doc, i) => \n                <DocumentContainer\n                  key={i}\n                  index={ i }\n                  displayIndex={( (this.state.pageNumber - 1) * 10 ) + i + 1  }\n                  words={doc}              \n                  annotations={this.state.annotations[i]}  \n                  confidence={this.state.confidences[i]}\n                  selections={this.state.selections[i]}\n                  updateSelections={this.updateSelections.bind(this)}\n                  updateConfidence={this.updateConfidence.bind(this)}\n                  entityColourMap={this.state.entityColourMap}\n                  deleteTag={this.deleteTag.bind(this)}\n                />\n                )}\n\n            </div>\n          </div>\n          <div id=\"tagging-menu\">\n            <WikipediaSummary tokens={this.state.mostRecentSelectionText}/>\n            <HotkeyInfo \n              chain={this.state.hotkeyChain}\n              entityClass={this.state.reverseHotkeyMap[this.state.hotkeyChain.join('')]}\n            />            \n            \n            <CategoryHierarchy\n              items={this.state.data.categoryHierarchy.children}\n              hotkeyMap={this.state.hotkeyMap}\n              hotkeyChain={this.state.hotkeyChain.join('')}\n              initHotkeyMap={this.initHotkeyMap.bind(this)}\n              applyTag={this.applyTag.bind(this)}              \n            />\n          </div>      \n        </div>\n      </div>\n    )\n  }\n}\n\n// The humble save button that appears at the top of the page.\nclass SaveButton extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n\n    var buttonClass = \" disabled\";\n    if(this.props.changesMade) buttonClass = \"\";\n    if(this.props.recentlySaved) buttonClass = \" recently-saved\";\n    if(this.props.saving) buttonClass = \" saving\";\n\n    var iconClass = \"fa-save\";\n    if(this.props.recentlySaved) iconClass = \"fa-check\";\n    if(this.props.saving) iconClass = \"fa-cog fa-spin\"\n\n    var text = \"Save\";\n    if(this.props.recentlySaved) text = \"Saved\";\n    if(this.props.saving) text = \"Saving\";\n\n    return (\n      <button className={\"save-button\" + buttonClass} onClick={this.props.submitAnnotations}>\n        <i className={\"fa \" + iconClass}></i>\n        { text }\n      </button>\n    )\n  }\n}\n\n\n// The progress bar that appears when the user saves a new doc group.\nclass ProgressBar extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-progress-bar\" className={(this.props.show ? \"show\" : \"hide\")}>\n        <span className=\"progress-bar\">\n          <span className=\"inner\" style={{\"width\": (this.props.totalPagesAvailable - 1) / this.props.totalPages * 100 + \"%\"}}></span>\n        </span>\n      </div>\n    )\n  }\n}\n\n// The 'control bar', which appears at the top of the interface (with page numbers, group number etc).\nclass ControlBar extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n\n    var groupName = (\n      <span className={\"group-name\" + (this.props.showingProgressBar ? \" progress-bar-underneath\" : \"\")}>\n        <span>Group <b>{this.props.pageNumber}</b> of <b>{this.props.totalPages}</b></span>\n      </span>\n    );\n\n    var latestGroup = (this.props.totalPagesAvailable) === this.props.pageNumber // Whether the user is looking at the latest group, that they have not yet annotated\n\n    var lastModified = this.props.lastModified ? \"Saved on \" + dateFormat(this.props.lastModified, 'dd mmm') + ' at ' + dateFormat(this.props.lastModified, 'h:MM tt') : (this.props.changesMade && !this.props.saving ? \"Changes not saved\" : \"\");\n\n    return (\n      <div id=\"pagination\">\n        <div className=\"page-button-container previous-page\">\n          <button className={(this.props.pageNumber === 1 ? \" disabled\" : \"\")} onClick={this.props.loadPreviousPage}><i className=\"fa fa-chevron-left\"></i>Prev\n          </button>\n        </div>\n        <div className=\"filler-left\"></div>\n        <div className=\"current-page-container\">\n          { groupName }\n          <ProgressBar \n            show={this.props.showingProgressBar}\n            totalPagesAvailable={this.props.totalPagesAvailable}\n            totalPages={this.props.totalPages}\n          />\n        </div>\n        <div className=\"group-last-modified\">{lastModified }</div>\n        <div className=\"page-button-container \"><SaveButton changesMade={this.props.changesMade} recentlySaved={this.props.recentlySaved} saving={this.props.saving} submitAnnotations={this.props.submitAnnotations}  /></div>\n        <div className=\"page-button-container next-page\">\n          <button className={(latestGroup ? \" disabled\" : \"\")}  onClick={this.props.loadNextPage}>Next<i className=\"fa fa-chevron-right\"></i></button>\n        </div>              \n      </div>\n    )\n  }\n}\n\nclass TaggingCompletePage extends Component {\n\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div id=\"tagging-complete-message\">\n        <span class=\"tagging-complete-text\">\n          <h2>Annotation complete!</h2>\n          <p>Thank you for your participation in this project.</p>\n\n        </span>\n\n\n      </div>\n    )\n\n  }\n}\n\n// The app, which renders the navbar and the tagging interface inside a container.\nfunction App() {\n  return (    \n    <TaggingInterface/>   \n  );\n}\n\n\n\nexport default App;\n\n// Old code\n/* \n<div className=\"submit-annotations-container\">\n  <button className=\"submit-annotations-button\" onClick={this.submitAnnotations.bind(this)}>Submit annotations <i className=\"fa fa-chevron-right\"></i></button>\n</div>\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}